# So, do not bother computing the inverse again, but just return the cached value.
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv <- NULL
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
get <- function () x
setinv <- function (inv) matrix_inv <<- inv
getinv <- function () matrix_inv
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes a square matrix as an argument and returns its inverse
## if it is not a singular matrix. The function checks the 'matrix_inv' variable to determine if
## the inverse was previously computed and could be gotten from the cached value instead of computing
## afresh.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
#
m <- x$get()
if det(m) == 0 {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function
matrix_inv <- solve(m, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
if (det(m) == 0) {
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv <- NULL
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
get <- function () x
setinv <- function (inv) matrix_inv <<- inv
getinv <- function () matrix_inv
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes a square matrix as an argument and returns its inverse
## if it is not a singular matrix. The function checks the 'matrix_inv' variable to determine if
## the inverse was previously computed and could be gotten from the cached value instead of computing
## afresh.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
#
m <- x$get()
if (det(m) == 0) {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function
matrix_inv <- solve(m, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
}
## Put comments here that give an overall description of what your
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv <- NULL
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
get <- function () x
setinv <- function (inv) matrix_inv <<- inv
getinv <- function () matrix_inv
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes a square matrix as an argument and returns its inverse
## if it is not a singular matrix. The function checks the 'matrix_inv' variable to determine if
## the inverse was previously computed and could be gotten from the cached value instead of computing
## afresh.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
#
m <- x$get()
if (det(m) == 0) {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function
matrix_inv <- solve(m, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
m <- makeCacheMatrix (matrix(51:99), nrow=7, ncol=7)
m <- matrix (51:99, nrow=7, ncol=7)
mm <- makeCacheMatrix (m)
cacheSolve (mm)
det(m)
m <- matrix (1:49, nrow=7, ncol=7)
mm <- makeCacheMatrix (m)
det(m)
mm <- makeCacheMatrix (m)
cacheSolve (mm)
cacheSolve (mm)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv <- NULL
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
get <- function () x
setinv <- function (inv) matrix_inv <<- inv
getinv <- function () matrix_inv
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes a square matrix as an argument and returns its inverse
## if it is not a singular matrix. The function checks the 'matrix_inv' variable to determine if
## the inverse was previously computed and could be gotten from the cached value instead of computing
## afresh.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
#
m <- x$get()
if (det(m) == 0) {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function
matrix_inv <- solve(m, tol=1e-18, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
m <- matrix (51:99, nrow=7, ncol=7)
mm <- makeCacheMatrix (m)
cacheSolve (mm)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv <- NULL
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
get <- function () x
setinv <- function (inv) matrix_inv <<- inv
getinv <- function () matrix_inv
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes a square matrix as an argument and returns its inverse
## if it is not a singular matrix. The function checks the 'matrix_inv' variable to determine if
## the inverse was previously computed and could be gotten from the cached value instead of computing
## afresh.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
#
m <- x$get()
if (det(m) == 0) {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function
matrix_inv <- solve(m, tol=1e-20, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
m <- matrix (51:99, nrow=7, ncol=7)
mm <- makeCacheMatrix (m)
cacheSolve (mm)
cacheSolve (mm)
cacheSolve (mm)
m <- matrix (51:99, nrow=7, ncol=7)
mm <- makeCacheMatrix (m)
cacheSolve (mm)
m
mm
m <- matrix (51:99, nrow=7, ncol=7)
mm <- makeCacheMatrix (m)
cacheSolve (mm)
mm
m
m %*% cacheSolve(mm)
mm
m %*% cacheSolve(m)
m %*% solve (m)
m %*% solve (m, tol=1e-20)
m %*% solve (m, tol=1e-19)
m %*% solve (m, tol=1e-18)
m %*% solve (m, tol=1e-19)
m <- matrix (1:49, nrow=7, ncol=7)
m %*% solve (m, tol=1e-19)
det(m)
m <- matrix (1:25, nrow=5, ncol=5)
det(m)
m <- matrix (51:99, nrow=7, ncol=7)
det(m)
?det
det(print(cbind(1, 1:3, c(2,0,1))))
cbind(1, 1:3, c(2,0,1))
m <- cbind(1, 1:3, c(2,0,1))
mm <- makeCacheMatrix (m)
m
mm
cacheSolve(mm)
cacheSolve(mm)
cacheSolve(mm)
m %*% cacheSolve(mm)
mm$get
mm$get ()
mm$set (m)
mm$get ()
mm$set (matrix (1:9, numrow=3))
mm$set (matrix (1:9))
mm$get ()
mm$matrix_inv
m <- cbind(1, 1:3, c(2,0,1))
mm <- makeCacheMatrix (m)
mm$matrix_inv
mm$get ()
mm$getinv()
cacheSolve(mm)
mm$getinv()
x$nrow
m$nrow
nrow(m)
ncol(m)
## Put comments here that give an overall description of what your
## functions do
## The function 'makeCacheMatrix' takes a square matrix as input and returns a list of functions
## which could be used to fetch the original matrix (using get), save the original matrix (using set),
## lookup the inverted matrix (using getinv) and save the inverted matrix (using setinv)
makeCacheMatrix <- function(x = matrix()) {
# Check if this is a square matrix
if (nrow(x) != ncol(x)) {
message ("Not a square matrix")
return (NULL)
}
# Clear out the initial inverted matrix
matrix_inv <- NULL
# This function saves the original matrix
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
# This function returns the saved original matrix
get <- function () x
# This function saves the inverted matrix
setinv <- function (inv) matrix_inv <<- inv
# This function returns the saved inverted matrix
getinv <- function () matrix_inv
# Finally, the list of functions which save and fetch the original and inverted matrices are returned.
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes as input the list of functions produced by the previous function
## 'makeCacheMatrix' and returns the inverse of the matrix specified therein. The function checks the
## 'matrix_inv' variable to determine if the inverse was previously computed and could be gotten from
## the cached value instead of computing afresh. If the inverse of this matrix is being computed for the
## first time, we check the determinant to ensure that this is not a singular matrix, which cannot be
## inverted. We then save the inverted matrix in the cache for future use and return it.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
# Get the original matrix and check its determinant to see if it singular
matrix <- x$get()
if (det(matrix) == 0) {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function. Relax the default tolerance settings as shown
matrix_inv <- solve(m, tol=1e-20, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
m <- cbind(1, 1:3, c(2,0,1))
mm <- makeCacheMatrix (m)
cacheSolve(mm)
cacheSolve(mm)
m <- cbind(1, 1:3, c(2,0,1), 2)
mm <- makeCacheMatrix (m)
cacheSolve(mm)
## The following set of functions are used to invert a square matrix, with additional functionality to
## cache and reuse previously inverted matrix values.
## The function 'makeCacheMatrix' takes a square matrix as input and returns a list of functions
## which could be used to fetch the original matrix (using get), save the original matrix (using set),
## lookup the inverted matrix (using getinv) and save the inverted matrix (using setinv)
makeCacheMatrix <- function(x = matrix()) {
# Check if this is a square matrix
if (nrow(x) != ncol(x)) {
message ("Not a square matrix")
return (NULL)
}
# Clear out the initial inverted matrix
matrix_inv <- NULL
# This function saves the original matrix
set <- function (y) {
x <<- y
matrix_inv <<- NULL
}
# This function returns the saved original matrix
get <- function () x
# This function saves the inverted matrix
setinv <- function (inv) matrix_inv <<- inv
# This function returns the saved inverted matrix
getinv <- function () matrix_inv
# Finally, the list of functions which save and fetch the original and inverted matrices are returned.
list (set = set, get = get, setinv = setinv, getinv = getinv)
}
## The 'cacheSolve' function takes as input the list of functions produced by the previous function
## 'makeCacheMatrix' and returns the inverse of the matrix specified therein. The function checks the
## 'matrix_inv' variable to determine if the inverse was previously computed and could be gotten from
## the cached value instead of computing afresh. If the inverse of this matrix is being computed for the
## first time, we check the determinant to ensure that this is not a singular matrix, which cannot be
## inverted. We then save the inverted matrix in the cache for future use and return it.
cacheSolve <- function(x, ...) {
# Get the matrix inverse from the defining environment
matrix_inv <- x$getinv()
# If the matrix inverse exists (not NULL), it probably was computed earlier and cached.
# So, do not bother computing the inverse again, but just return the cached value.
if (!is.null(matrix_inv)) {
message ("Getting cached matrix inverse")
return (matrix_inv)
}
# Get the original matrix and check its determinant to see if it singular
matrix <- x$get()
if (det(matrix) == 0) {
message ("Unable to get the inverse of a singular matrix")
return (NULL)
}
# Get the inverse of this matrix using the 'solve' function. Relax the default tolerance settings as shown
matrix_inv <- solve(m, tol=1e-20, ...)
# Save the inverse matrix in the cache, which is in defining environment
x$setinv (matrix_inv)
# Return the newly computed inverse matrix
return (matrix_inv)
}
m <- cbind(1, 1:3, c(2,0,1), 2)
mm <- makeCacheMatrix (m)
m <- cbind(1, 1:4, c(2,0,1,3),2)
mm <- makeCacheMatrix (m)
cacheSolve(mm)
m <- cbind(1, 1:4, c(2,0,1,8), 9)
mm <- makeCacheMatrix (m)
cacheSolve(mm)
View(m)
view (mm)
View(m)
view(m)
View(mm)
View(mm$getinv)
